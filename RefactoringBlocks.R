#' Binary Sequence (String) Split
#' 
#' Function that takes in a string vector and converts it into a matrix. 
#' 
#' binsplit(x = c("10101","01001")
#' 
#' @param x string vector containing binary strings of length k and q strings
#' @return q x k matrix containing the binary string 
#' @export
#' 
binsplit <- function(x) {
  binaryseq = as.matrix(strsplit(x, ""))
  parsebin = do.call(rbind, binaryseq)
  matrix(as.numeric(parsebin), nrow = nrow(parsebin))
  testgen = matrix(as.numeric(parsebin), nrow = nrow(parsebin))
  return(testgen)
}


#' Aliases of the Defining Relation
#' 
#' Function that takes in a matrix whose rows contain elements of a 
#' binary string of length k (output of binsplit())
#' 
#' @param x n by q matrix from output of binsplit (binary sequence matrix)
#' @return A column vector containing aliases of the q confounded variables expressed in binary
#' @export
aliasesI <- function(x)
{
  q = nrow(x)
  if (q == 1) {
    set = conf.set(testgen, 2)
    str.set = matrix(0, nrow = 1, ncol = 1)
    str.set[1] = paste(set, collapse = "")
  }
  else if (q >= 2) {
    set = conf.set(testgen, 2)
    str.set = matrix(rep(0, nrow(set)), nrow = nrow(set), ncol = 1)
    for (i in 1:nrow(set)) {
      str.set[i] = paste(set[i,], collapse = "")
    }
  }
  return(str.set)
}

#' Standard Order
#' 
#' Function that enumerates standard order for k factors
#' More generally, standard order may be considered as all the combinations
#' of 0's nad 1's put together into a binary string of length k. There is some similarities
#' to generating truth tables (combinations of all TRUE and FALSE)
#' 
#' @param k integer describing the length of all binary strings
#' @param q integer describing the number of confounded variables in the defining relation.
#' @return Column vector containing standard ordered binary sequences
#' @export
standardorder <- function(k, q) {
  ntrt = 2^k
  nblock = 2^q
  input = expand.grid(replicate(k, 0:1, simplify = FALSE))
  str.input = matrix(rep(0, nrow(input)), nrow = nrow(input), ncol = 1)
  for (i in 1:nrow(input)) {
    str.input[i] =  paste(input[i,], collapse = "")
  }
  return(str.input)
}

#' Constructor for confounded variable list
#' 
#' Constructor that generates a list with q components, 
#' one for each confounded variable in the defining relation
#' 
#' @param q integer describing the number of confounded variables in the defining relation.
#' @param x string vector containing binary strings of length k and q strings
#' @return List with q component; each component its name associated with a confounded variable.
#' @export
confoundedlist <- function(q, x) {
  # Enumerating inputted confounders into a list
  confounder <- rep(list(NULL), q)
  names(confounder) <- paste("confounder", 1:q, sep = "")
  for (i in 1:q) {
    confounder[[i]] <- x[i]
  }
  return(confounder)
}
  


# Function parity blocks (forms cosets based on parity)
# Args: 
# int k length of binary string, 
# int q nummber of confounders,
# list confounder (generated by function confoundedlist())
# What it does:
# Taking subset of standard ordered treatments
# Subset is defined by confounding variable
# E.g. if we're in 2^4 design {A,B,C,D} main effects
#      and we want to confound BCD
#      We should only inspect columns B,C,D when doing addition mod 2
# Returns
# Generates a table output of construction of the cosets (blocks)
# Returns blocks

#' Parity Blocks (forms cosets based on parity)
#' 
#' Function that generates a table that follows a general algorithm of constructing blocks
#' 
#' @param confounder a list initialized to have q components and names associated with confounded variables
#' @param q integer describing the number of confounded variables in the defining relation
#' @param k intger describing the length of all binary strings
#' @param binaryCol boolean argument if name of columns should be binary
#' @param table boolean argument if the table should be printed
#' @param printset boolean argument if the blocks should be printed
#' @return Dataframe containing blocks.
#' @export
parityblocks <- function(k, q, confounder, binaryCol, table, printset)
{
  ntrt = 2^k
  nblock = 2^q
  len = nchar(confounder[[1]])
  matching <- rep(list(NULL), q)
  names(matching) = paste("match", 1:q, sep = "")
  # Three is an implausible value in arithmetic modulo 2
  for (i in 1:q) {
    matching[[i]] =  matrix(rep(rep(3, len), nrow(input)), nrow = nrow(input))
    for (j in 1:(ntrt)) {
      for (b in 1:len) {
        matching[[i]][j, b] = (substr(str.input[j],b,b) == substr(confounder[[i]],b,b))
      }
    }
  }
  for (i in 1:q) {
    matching[[i]] <- matching[[i]][, which(strsplit(x[i], "")[[1]]=="1")]
    matching[[i]] <- as.matrix(apply(matching[[i]], 1, sum))
    matching[[i]] <- matching[[i]] %% 2
  }
  # Re-naming 0 to even, and 1 to odd
  for (i in 1:q) {
    for (m in 1:ntrt) {
      if (matching[[i]][m] == 1) {
        matching[[i]][m] <- "o"
      } 
      else if (matching[[i]][m] == 0) {
        matching[[i]][m] <- "e"
      }
    }
  }
  # Giving treatment names to standard ordered treatments
  term <- matrix((rep("", ntrt)), nrow = ntrt)
  term[1] <- "(1)"
  for (i in 1:ntrt) {
    for(j in 1:k) {
      if (substr(str.input[i], j, j) == 1) {
        term[i] <- paste(term[i], letters[j], sep = "")
      }
    }
  }
  # Declare and initialize 2^q blocks
  block <- rep(list(NULL), nblock)
  names(block) <- paste("block", 1:nblock, sep = "")
  parity = expand.grid(replicate(q, c("e", "o"), simplify = FALSE))
  str.parity = matrix(rep("", nrow(parity)), nrow = nrow(parity), ncol = 1)
  for (i in 1:nrow(parity)) {
    # Generalize it to 1,...,q
    str.parity[i] = paste(as.matrix(parity[i,1:q]), collapse = "")
  }
  constructblock <- cbind(term, str.input)
  for (i in 1:q) {
    constructblock <- cbind(constructblock, matching[[i]])
  }
  if (q == 1) { 
    l = constructblock[,3]
  } else {
    l = apply(subset(constructblock[,3:(2+q)]), 1, paste, collapse = "")
  }
  
  for (i in 1:nblock){
    #block[[i]] = which(paste(constructblock[1:32,3:(2+q)], collapse = "") == str.parity[i])
    block[[i]] = which(l == str.parity[[i]])
  }
  blocknumber <- matrix((rep(0, dim(constructblock)[1])), nrow = dim(constructblock)[1])
  for(i in 1:nblock) {
    blocknumber[block[[i]]] <- i
  }
  constructblock <- cbind(constructblock, blocknumber)
  # Add the generalized interaction (confounded interaction terms)
  # This would correspond to taking the confounders, summing entrywise, taking mod 2
  # then associating the result with an input in the list of standard ordered treatments.
  # names(constructblock) <- c("Treatment", "Std. Order", ""....,, blocknumber)
  # this needs to spell out the confounder over the .... columns
  results <- rep(list(NULL), nblock)
  names(results) <- paste(str.parity, "block", sep = "")
  for (i in 1:length(results)) {
    results[[i]] <- constructblock[block[[i]], 1]
  }
  # Print confounded set (defn contrasts + generalized interaction)
  ind <- matrix(rep(0, length(str.set)), nrow = length(str.set))
  for (i in 1:length(str.set)) {
    ind[i] = which(str.set[i] == constructblock[,2])
  }
  confset = constructblock[ind, 1]
  if (printset == TRUE) {
    cat("The confounded set is \n")
    cat("{", toupper(as.character(confset)),"}\n")
  }
  constructblock <- as.data.frame(constructblock)
  if (binaryCol == TRUE) {
    colnames(constructblock) <- c("treatment", "binary trt", 
                                  x, "blocknumber")
  }
  colnames(constructblock) <- c("treatment", "binary trt", 
                                toupper(as.character(constructblock[match(x, constructblock[,2]),1])),
                                "blocknumber")
  if (table == TRUE) {
    print(constructblock)
  }
  results <- as.data.frame(results)
  results
}


